{"version":3,"sources":["node_modules/jsep/build/jsep.js","node_modules/expression-eval/index.js","index.js","node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["root","COMPOUND","IDENTIFIER","MEMBER_EXP","LITERAL","THIS_EXP","CALL_EXP","UNARY_EXP","BINARY_EXP","LOGICAL_EXP","CONDITIONAL_EXP","ARRAY_EXP","PERIOD_CODE","COMMA_CODE","SQUOTE_CODE","DQUOTE_CODE","OPAREN_CODE","CPAREN_CODE","OBRACK_CODE","CBRACK_CODE","QUMARK_CODE","SEMCOL_CODE","COLON_CODE","throwError","message","index","error","Error","description","t","unary_ops","binary_ops","getMaxKeyLen","obj","max_len","len","key","length","hasOwnProperty","max_unop_len","max_binop_len","literals","this_str","binaryPrecedence","op_val","createBinaryExpression","operator","left","right","type","isDecimalDigit","ch","isIdentifierStart","String","fromCharCode","isIdentifierPart","jsep","expr","charAtFunc","charAt","charCodeAtFunc","charCodeAt","exprI","i","call","exprICode","gobbleSpaces","gobbleExpression","test","gobbleBinaryExpression","consequent","alternate","gobbleBinaryOp","biop","to_check","substr","tc_len","ch_i","node","prec","stack","biop_info","gobbleToken","value","pop","push","gobbleNumericLiteral","gobbleStringLiteral","gobbleArray","argument","prefix","gobbleVariable","number","chCode","parseFloat","raw","str","quote","closed","gobbleIdentifier","start","identifier","slice","name","gobbleArguments","termination","args","gobbleGroup","computed","object","property","callee","elements","nodes","body","version","toString","addUnaryOp","op_name","Math","max","addBinaryOp","precedence","addLiteral","literal_name","literal_value","removeUnaryOp","removeAllUnaryOps","removeBinaryOp","removeAllBinaryOps","removeLiteral","removeAllLiterals","exports","old_jsep","noConflict","module","parse","console","log","eval","OVERLAY_ID","OldModule","bundle","Module","moduleName","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","dispose","checkedAssets","assetsToAccept","parent","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","handled","assets","forEach","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","id","every","generated","js","clear","hmrApply","v","hmrAcceptRun","window","reload","close","onclose","removeErrorOverlay","overlay","createErrorOverlay","document","appendChild","getElementById","remove","createElement","stackTrace","innerText","innerHTML","getParents","modules","parents","k","d","dep","Array","isArray","concat","Function","deps","cached","cache","some","cb"],"mappings":"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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtNA;;;;AAEAiF,OAAO,CAACC,GAAR,CAAYjF,IAAI,CAACkF,IAAL,CAAUlF,IAAI,CAAC+E,KAAL,CAAW,SAAX,CAAV,CAAZ;;;ACFA,IAAII,UAAU,GAAG,4BAAjB;AAEA,IAAIC,SAAS,GAAGN,MAAM,CAACO,MAAP,CAAcC,MAA9B;;AAEA,SAASA,MAAT,CAAgBC,UAAhB,EAA4B;AAC1BH,EAAAA,SAAS,CAAC7E,IAAV,CAAe,IAAf,EAAqBgF,UAArB;AACA,OAAKC,GAAL,GAAW;AACTC,IAAAA,IAAI,EAAEX,MAAM,CAACO,MAAP,CAAcK,OADX;AAETC,IAAAA,gBAAgB,EAAE,EAFT;AAGTC,IAAAA,iBAAiB,EAAE,EAHV;AAITC,IAAAA,MAAM,EAAE,UAAUC,EAAV,EAAc;AACpB,WAAKH,gBAAL,CAAsB/D,IAAtB,CAA2BkE,EAAE,IAA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","file":"index.js","sourceRoot":"..","sourcesContent":["//     JavaScript Expression Parser (JSEP) 0.3.4\r\n//     JSEP may be freely distributed under the MIT License\r\n//     http://jsep.from.so/\r\n\r\n/*global module: true, exports: true, console: true */\r\n(function (root) {\r\n\t'use strict';\r\n\t// Node Types\r\n\t// ----------\r\n\r\n\t// This is the full set of types that any JSEP node can be.\r\n\t// Store them here to save space when minified\r\n\tvar COMPOUND = 'Compound',\r\n\t\tIDENTIFIER = 'Identifier',\r\n\t\tMEMBER_EXP = 'MemberExpression',\r\n\t\tLITERAL = 'Literal',\r\n\t\tTHIS_EXP = 'ThisExpression',\r\n\t\tCALL_EXP = 'CallExpression',\r\n\t\tUNARY_EXP = 'UnaryExpression',\r\n\t\tBINARY_EXP = 'BinaryExpression',\r\n\t\tLOGICAL_EXP = 'LogicalExpression',\r\n\t\tCONDITIONAL_EXP = 'ConditionalExpression',\r\n\t\tARRAY_EXP = 'ArrayExpression',\r\n\r\n\t\tPERIOD_CODE = 46, // '.'\r\n\t\tCOMMA_CODE  = 44, // ','\r\n\t\tSQUOTE_CODE = 39, // single quote\r\n\t\tDQUOTE_CODE = 34, // double quotes\r\n\t\tOPAREN_CODE = 40, // (\r\n\t\tCPAREN_CODE = 41, // )\r\n\t\tOBRACK_CODE = 91, // [\r\n\t\tCBRACK_CODE = 93, // ]\r\n\t\tQUMARK_CODE = 63, // ?\r\n\t\tSEMCOL_CODE = 59, // ;\r\n\t\tCOLON_CODE  = 58, // :\r\n\r\n\t\tthrowError = function(message, index) {\r\n\t\t\tvar error = new Error(message + ' at character ' + index);\r\n\t\t\terror.index = index;\r\n\t\t\terror.description = message;\r\n\t\t\tthrow error;\r\n\t\t},\r\n\r\n\t// Operations\r\n\t// ----------\r\n\r\n\t// Set `t` to `true` to save space (when minified, not gzipped)\r\n\t\tt = true,\r\n\t// Use a quickly-accessible map to store all of the unary operators\r\n\t// Values are set to `true` (it really doesn't matter)\r\n\t\tunary_ops = {'-': t, '!': t, '~': t, '+': t},\r\n\t// Also use a map for the binary operations but set their values to their\r\n\t// binary precedence for quick reference:\r\n\t// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\r\n\t\tbinary_ops = {\r\n\t\t\t'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,\r\n\t\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\r\n\t\t\t'<': 7,  '>': 7,  '<=': 7,  '>=': 7,\r\n\t\t\t'<<':8,  '>>': 8, '>>>': 8,\r\n\t\t\t'+': 9, '-': 9,\r\n\t\t\t'*': 10, '/': 10, '%': 10\r\n\t\t},\r\n\t// Get return the longest key length of any object\r\n\t\tgetMaxKeyLen = function(obj) {\r\n\t\t\tvar max_len = 0, len;\r\n\t\t\tfor(var key in obj) {\r\n\t\t\t\tif((len = key.length) > max_len && obj.hasOwnProperty(key)) {\r\n\t\t\t\t\tmax_len = len;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn max_len;\r\n\t\t},\r\n\t\tmax_unop_len = getMaxKeyLen(unary_ops),\r\n\t\tmax_binop_len = getMaxKeyLen(binary_ops),\r\n\t// Literals\r\n\t// ----------\r\n\t// Store the values to return for the various literals we may encounter\r\n\t\tliterals = {\r\n\t\t\t'true': true,\r\n\t\t\t'false': false,\r\n\t\t\t'null': null\r\n\t\t},\r\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\r\n\t\tthis_str = 'this',\r\n\t// Returns the precedence of a binary operator or `0` if it isn't a binary operator\r\n\t\tbinaryPrecedence = function(op_val) {\r\n\t\t\treturn binary_ops[op_val] || 0;\r\n\t\t},\r\n\t// Utility function (gets called from multiple places)\r\n\t// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\r\n\t\tcreateBinaryExpression = function (operator, left, right) {\r\n\t\t\tvar type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;\r\n\t\t\treturn {\r\n\t\t\t\ttype: type,\r\n\t\t\t\toperator: operator,\r\n\t\t\t\tleft: left,\r\n\t\t\t\tright: right\r\n\t\t\t};\r\n\t\t},\r\n\t\t// `ch` is a character code in the next three functions\r\n\t\tisDecimalDigit = function(ch) {\r\n\t\t\treturn (ch >= 48 && ch <= 57); // 0...9\r\n\t\t},\r\n\t\tisIdentifierStart = function(ch) {\r\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\r\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\r\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\r\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\r\n\t\t},\r\n\t\tisIdentifierPart = function(ch) {\r\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\r\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\r\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\r\n\t\t\t\t\t(ch >= 48 && ch <= 57) || // 0...9\r\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\r\n\t\t},\r\n\r\n\t\t// Parsing\r\n\t\t// -------\r\n\t\t// `expr` is a string with the passed in expression\r\n\t\tjsep = function(expr) {\r\n\t\t\t// `index` stores the character number we are currently at while `length` is a constant\r\n\t\t\t// All of the gobbles below will modify `index` as we move along\r\n\t\t\tvar index = 0,\r\n\t\t\t\tcharAtFunc = expr.charAt,\r\n\t\t\t\tcharCodeAtFunc = expr.charCodeAt,\r\n\t\t\t\texprI = function(i) { return charAtFunc.call(expr, i); },\r\n\t\t\t\texprICode = function(i) { return charCodeAtFunc.call(expr, i); },\r\n\t\t\t\tlength = expr.length,\r\n\r\n\t\t\t\t// Push `index` up to the next non-space character\r\n\t\t\t\tgobbleSpaces = function() {\r\n\t\t\t\t\tvar ch = exprICode(index);\r\n\t\t\t\t\t// space or tab\r\n\t\t\t\t\twhile(ch === 32 || ch === 9 || ch === 10 || ch === 13) {\r\n\t\t\t\t\t\tch = exprICode(++index);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// The main parsing function. Much of this code is dedicated to ternary expressions\r\n\t\t\t\tgobbleExpression = function() {\r\n\t\t\t\t\tvar test = gobbleBinaryExpression(),\r\n\t\t\t\t\t\tconsequent, alternate;\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tif(exprICode(index) === QUMARK_CODE) {\r\n\t\t\t\t\t\t// Ternary expression: test ? consequent : alternate\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\tconsequent = gobbleExpression();\r\n\t\t\t\t\t\tif(!consequent) {\r\n\t\t\t\t\t\t\tthrowError('Expected expression', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tif(exprICode(index) === COLON_CODE) {\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t\talternate = gobbleExpression();\r\n\t\t\t\t\t\t\tif(!alternate) {\r\n\t\t\t\t\t\t\t\tthrowError('Expected expression', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\ttype: CONDITIONAL_EXP,\r\n\t\t\t\t\t\t\t\ttest: test,\r\n\t\t\t\t\t\t\t\tconsequent: consequent,\r\n\t\t\t\t\t\t\t\talternate: alternate\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrowError('Expected :', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn test;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Search for the operation portion of the string (e.g. `+`, `===`)\r\n\t\t\t\t// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\r\n\t\t\t\t// and move down from 3 to 2 to 1 character until a matching binary operation is found\r\n\t\t\t\t// then, return that binary operation\r\n\t\t\t\tgobbleBinaryOp = function() {\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tvar biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;\r\n\t\t\t\t\twhile(tc_len > 0) {\r\n\t\t\t\t\t\t// Don't accept a binary op when it is an identifier.\r\n\t\t\t\t\t\t// Binary ops that start with a identifier-valid character must be followed\r\n\t\t\t\t\t\t// by a non identifier-part valid character\r\n\t\t\t\t\t\tif(binary_ops.hasOwnProperty(to_check) && (\r\n\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\r\n\t\t\t\t\t\t\t(index+to_check.length< expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\r\n\t\t\t\t\t\t)) {\r\n\t\t\t\t\t\t\tindex += tc_len;\r\n\t\t\t\t\t\t\treturn to_check;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// This function is responsible for gobbling an individual expression,\r\n\t\t\t\t// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\r\n\t\t\t\tgobbleBinaryExpression = function() {\r\n\t\t\t\t\tvar ch_i, node, biop, prec, stack, biop_info, left, right, i;\r\n\r\n\t\t\t\t\t// First, try to get the leftmost thing\r\n\t\t\t\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\r\n\t\t\t\t\tleft = gobbleToken();\r\n\t\t\t\t\tbiop = gobbleBinaryOp();\r\n\r\n\t\t\t\t\t// If there wasn't a binary operator, just return the leftmost node\r\n\t\t\t\t\tif(!biop) {\r\n\t\t\t\t\t\treturn left;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\r\n\t\t\t\t\t// precedence structure\r\n\t\t\t\t\tbiop_info = { value: biop, prec: binaryPrecedence(biop)};\r\n\r\n\t\t\t\t\tright = gobbleToken();\r\n\t\t\t\t\tif(!right) {\r\n\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstack = [left, biop_info, right];\r\n\r\n\t\t\t\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\r\n\t\t\t\t\twhile((biop = gobbleBinaryOp())) {\r\n\t\t\t\t\t\tprec = binaryPrecedence(biop);\r\n\r\n\t\t\t\t\t\tif(prec === 0) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbiop_info = { value: biop, prec: prec };\r\n\r\n\t\t\t\t\t\t// Reduce: make a binary expression from the three topmost entries.\r\n\t\t\t\t\t\twhile ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\r\n\t\t\t\t\t\t\tright = stack.pop();\r\n\t\t\t\t\t\t\tbiop = stack.pop().value;\r\n\t\t\t\t\t\t\tleft = stack.pop();\r\n\t\t\t\t\t\t\tnode = createBinaryExpression(biop, left, right);\r\n\t\t\t\t\t\t\tstack.push(node);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnode = gobbleToken();\r\n\t\t\t\t\t\tif(!node) {\r\n\t\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstack.push(biop_info, node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ti = stack.length - 1;\r\n\t\t\t\t\tnode = stack[i];\r\n\t\t\t\t\twhile(i > 1) {\r\n\t\t\t\t\t\tnode = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\r\n\t\t\t\t\t\ti -= 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// An individual part of a binary expression:\r\n\t\t\t\t// e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\r\n\t\t\t\tgobbleToken = function() {\r\n\t\t\t\t\tvar ch, to_check, tc_len;\r\n\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tch = exprICode(index);\r\n\r\n\t\t\t\t\tif(isDecimalDigit(ch) || ch === PERIOD_CODE) {\r\n\t\t\t\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\r\n\t\t\t\t\t\treturn gobbleNumericLiteral();\r\n\t\t\t\t\t} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\r\n\t\t\t\t\t\t// Single or double quotes\r\n\t\t\t\t\t\treturn gobbleStringLiteral();\r\n\t\t\t\t\t} else if (ch === OBRACK_CODE) {\r\n\t\t\t\t\t\treturn gobbleArray();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tto_check = expr.substr(index, max_unop_len);\r\n\t\t\t\t\t\ttc_len = to_check.length;\r\n\t\t\t\t\t\twhile(tc_len > 0) {\r\n\t\t\t\t\t\t// Don't accept an unary op when it is an identifier.\r\n\t\t\t\t\t\t// Unary ops that start with a identifier-valid character must be followed\r\n\t\t\t\t\t\t// by a non identifier-part valid character\r\n\t\t\t\t\t\t\tif(unary_ops.hasOwnProperty(to_check) && (\r\n\t\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\r\n\t\t\t\t\t\t\t\t(index+to_check.length < expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\r\n\t\t\t\t\t\t\t)) {\r\n\t\t\t\t\t\t\t\tindex += tc_len;\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\ttype: UNARY_EXP,\r\n\t\t\t\t\t\t\t\t\toperator: to_check,\r\n\t\t\t\t\t\t\t\t\targument: gobbleToken(),\r\n\t\t\t\t\t\t\t\t\tprefix: true\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\r\n\t\t\t\t\t\t\t// `foo`, `bar.baz`\r\n\t\t\t\t\t\t\treturn gobbleVariable();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t},\r\n\t\t\t\t// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\r\n\t\t\t\t// keep track of everything in the numeric literal and then calling `parseFloat` on that string\r\n\t\t\t\tgobbleNumericLiteral = function() {\r\n\t\t\t\t\tvar number = '', ch, chCode;\r\n\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\r\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tch = exprI(index);\r\n\t\t\t\t\tif(ch === 'e' || ch === 'E') { // exponent marker\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\tch = exprI(index);\r\n\t\t\t\t\t\tif(ch === '+' || ch === '-') { // exponent sign\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) { //exponent itself\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(!isDecimalDigit(exprICode(index-1)) ) {\r\n\t\t\t\t\t\t\tthrowError('Expected exponent (' + number + exprI(index) + ')', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tchCode = exprICode(index);\r\n\t\t\t\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\r\n\t\t\t\t\tif(isIdentifierStart(chCode)) {\r\n\t\t\t\t\t\tthrowError('Variable names cannot start with a number (' +\r\n\t\t\t\t\t\t\t\t\tnumber + exprI(index) + ')', index);\r\n\t\t\t\t\t} else if(chCode === PERIOD_CODE) {\r\n\t\t\t\t\t\tthrowError('Unexpected period', index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\tvalue: parseFloat(number),\r\n\t\t\t\t\t\traw: number\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Parses a string literal, staring with single or double quotes with basic support for escape codes\r\n\t\t\t\t// e.g. `\"hello world\"`, `'this is\\nJSEP'`\r\n\t\t\t\tgobbleStringLiteral = function() {\r\n\t\t\t\t\tvar str = '', quote = exprI(index++), closed = false, ch;\r\n\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tch = exprI(index++);\r\n\t\t\t\t\t\tif(ch === quote) {\r\n\t\t\t\t\t\t\tclosed = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if(ch === '\\\\') {\r\n\t\t\t\t\t\t\t// Check for all of the common escape codes\r\n\t\t\t\t\t\t\tch = exprI(index++);\r\n\t\t\t\t\t\t\tswitch(ch) {\r\n\t\t\t\t\t\t\t\tcase 'n': str += '\\n'; break;\r\n\t\t\t\t\t\t\t\tcase 'r': str += '\\r'; break;\r\n\t\t\t\t\t\t\t\tcase 't': str += '\\t'; break;\r\n\t\t\t\t\t\t\t\tcase 'b': str += '\\b'; break;\r\n\t\t\t\t\t\t\t\tcase 'f': str += '\\f'; break;\r\n\t\t\t\t\t\t\t\tcase 'v': str += '\\x0B'; break;\r\n\t\t\t\t\t\t\t\tdefault : str += ch;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstr += ch;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(!closed) {\r\n\t\t\t\t\t\tthrowError('Unclosed quote after \"'+str+'\"', index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\tvalue: str,\r\n\t\t\t\t\t\traw: quote + str + quote\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobbles only identifiers\r\n\t\t\t\t// e.g.: `foo`, `_value`, `$x1`\r\n\t\t\t\t// Also, this function checks if that identifier is a literal:\r\n\t\t\t\t// (e.g. `true`, `false`, `null`) or `this`\r\n\t\t\t\tgobbleIdentifier = function() {\r\n\t\t\t\t\tvar ch = exprICode(index), start = index, identifier;\r\n\r\n\t\t\t\t\tif(isIdentifierStart(ch)) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrowError('Unexpected ' + exprI(index), index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tch = exprICode(index);\r\n\t\t\t\t\t\tif(isIdentifierPart(ch)) {\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tidentifier = expr.slice(start, index);\r\n\r\n\t\t\t\t\tif(literals.hasOwnProperty(identifier)) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\t\tvalue: literals[identifier],\r\n\t\t\t\t\t\t\traw: identifier\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else if(identifier === this_str) {\r\n\t\t\t\t\t\treturn { type: THIS_EXP };\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: IDENTIFIER,\r\n\t\t\t\t\t\t\tname: identifier\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobbles a list of arguments within the context of a function call\r\n\t\t\t\t// or array literal. This function also assumes that the opening character\r\n\t\t\t\t// `(` or `[` has already been gobbled, and gobbles expressions and commas\r\n\t\t\t\t// until the terminator character `)` or `]` is encountered.\r\n\t\t\t\t// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\r\n\t\t\t\tgobbleArguments = function(termination) {\r\n\t\t\t\t\tvar ch_i, args = [], node, closed = false;\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t\tif(ch_i === termination) { // done parsing\r\n\t\t\t\t\t\t\tclosed = true;\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if (ch_i === COMMA_CODE) { // between expressions\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnode = gobbleExpression();\r\n\t\t\t\t\t\t\tif(!node || node.type === COMPOUND) {\r\n\t\t\t\t\t\t\t\tthrowError('Expected comma', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\targs.push(node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!closed) {\r\n\t\t\t\t\t\tthrowError('Expected ' + String.fromCharCode(termination), index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn args;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobble a non-literal variable name. This variable name may include properties\r\n\t\t\t\t// e.g. `foo`, `bar.baz`, `foo['bar'].baz`\r\n\t\t\t\t// It also gobbles function calls:\r\n\t\t\t\t// e.g. `Math.acos(obj.angle)`\r\n\t\t\t\tgobbleVariable = function() {\r\n\t\t\t\t\tvar ch_i, node;\r\n\t\t\t\t\tch_i = exprICode(index);\r\n\r\n\t\t\t\t\tif(ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\tnode = gobbleGroup();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode = gobbleIdentifier();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\twhile(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\tif(ch_i === PERIOD_CODE) {\r\n\t\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\r\n\t\t\t\t\t\t\t\tcomputed: false,\r\n\t\t\t\t\t\t\t\tobject: node,\r\n\t\t\t\t\t\t\t\tproperty: gobbleIdentifier()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t} else if(ch_i === OBRACK_CODE) {\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\r\n\t\t\t\t\t\t\t\tcomputed: true,\r\n\t\t\t\t\t\t\t\tobject: node,\r\n\t\t\t\t\t\t\t\tproperty: gobbleExpression()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t\t\tif(ch_i !== CBRACK_CODE) {\r\n\t\t\t\t\t\t\t\tthrowError('Unclosed [', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else if(ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\t\t// A function call is being made; gobble all the arguments\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: CALL_EXP,\r\n\t\t\t\t\t\t\t\t'arguments': gobbleArguments(CPAREN_CODE),\r\n\t\t\t\t\t\t\t\tcallee: node\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Responsible for parsing a group of things within parentheses `()`\r\n\t\t\t\t// This function assumes that it needs to gobble the opening parenthesis\r\n\t\t\t\t// and then tries to gobble everything within that parenthesis, assuming\r\n\t\t\t\t// that the next thing it should see is the close parenthesis. If not,\r\n\t\t\t\t// then the expression probably doesn't have a `)`\r\n\t\t\t\tgobbleGroup = function() {\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t\tvar node = gobbleExpression();\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tif(exprICode(index) === CPAREN_CODE) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrowError('Unclosed (', index);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Responsible for parsing Array literals `[1, 2, 3]`\r\n\t\t\t\t// This function assumes that it needs to gobble the opening bracket\r\n\t\t\t\t// and then tries to gobble the expressions as arguments.\r\n\t\t\t\tgobbleArray = function() {\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: ARRAY_EXP,\r\n\t\t\t\t\t\telements: gobbleArguments(CBRACK_CODE)\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\tnodes = [], ch_i, node;\r\n\r\n\t\t\twhile(index < length) {\r\n\t\t\t\tch_i = exprICode(index);\r\n\r\n\t\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\r\n\t\t\t\t// separators\r\n\t\t\t\tif(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\r\n\t\t\t\t\tindex++; // ignore separators\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Try to gobble each expression individually\r\n\t\t\t\t\tif((node = gobbleExpression())) {\r\n\t\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\r\n\t\t\t\t\t// the expression passed in probably has too much\r\n\t\t\t\t\t} else if(index < length) {\r\n\t\t\t\t\t\tthrowError('Unexpected \"' + exprI(index) + '\"', index);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If there's only one expression just try returning the expression\r\n\t\t\tif(nodes.length === 1) {\r\n\t\t\t\treturn nodes[0];\r\n\t\t\t} else {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: COMPOUND,\r\n\t\t\t\t\tbody: nodes\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t// To be filled in by the template\r\n\tjsep.version = '0.3.4';\r\n\tjsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };\r\n\r\n\t/**\r\n\t * @method jsep.addUnaryOp\r\n\t * @param {string} op_name The name of the unary op to add\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addUnaryOp = function(op_name) {\r\n\t\tmax_unop_len = Math.max(op_name.length, max_unop_len);\r\n\t\tunary_ops[op_name] = t; return this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.addBinaryOp\r\n\t * @param {string} op_name The name of the binary op to add\r\n\t * @param {number} precedence The precedence of the binary op (can be a float)\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addBinaryOp = function(op_name, precedence) {\r\n\t\tmax_binop_len = Math.max(op_name.length, max_binop_len);\r\n\t\tbinary_ops[op_name] = precedence;\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.addLiteral\r\n\t * @param {string} literal_name The name of the literal to add\r\n\t * @param {*} literal_value The value of the literal\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addLiteral = function(literal_name, literal_value) {\r\n\t\tliterals[literal_name] = literal_value;\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeUnaryOp\r\n\t * @param {string} op_name The name of the unary op to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeUnaryOp = function(op_name) {\r\n\t\tdelete unary_ops[op_name];\r\n\t\tif(op_name.length === max_unop_len) {\r\n\t\t\tmax_unop_len = getMaxKeyLen(unary_ops);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllUnaryOps\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllUnaryOps = function() {\r\n\t\tunary_ops = {};\r\n\t\tmax_unop_len = 0;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeBinaryOp\r\n\t * @param {string} op_name The name of the binary op to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeBinaryOp = function(op_name) {\r\n\t\tdelete binary_ops[op_name];\r\n\t\tif(op_name.length === max_binop_len) {\r\n\t\t\tmax_binop_len = getMaxKeyLen(binary_ops);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllBinaryOps\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllBinaryOps = function() {\r\n\t\tbinary_ops = {};\r\n\t\tmax_binop_len = 0;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeLiteral\r\n\t * @param {string} literal_name The name of the literal to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeLiteral = function(literal_name) {\r\n\t\tdelete literals[literal_name];\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllLiterals\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllLiterals = function() {\r\n\t\tliterals = {};\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// In desktop environments, have a way to restore the old value for `jsep`\r\n\tif (typeof exports === 'undefined') {\r\n\t\tvar old_jsep = root.jsep;\r\n\t\t// The star of the show! It's a function!\r\n\t\troot.jsep = jsep;\r\n\t\t// And a courteous function willing to move out of the way for other similarly-named objects!\r\n\t\tjsep.noConflict = function() {\r\n\t\t\tif(root.jsep === jsep) {\r\n\t\t\t\troot.jsep = old_jsep;\r\n\t\t\t}\r\n\t\t\treturn jsep;\r\n\t\t};\r\n\t} else {\r\n\t\t// In Node.JS environments\r\n\t\tif (typeof module !== 'undefined' && module.exports) {\r\n\t\t\texports = module.exports = jsep;\r\n\t\t} else {\r\n\t\t\texports.parse = jsep;\r\n\t\t}\r\n\t}\r\n}(this));\r\n","const jsep = require('jsep');\n\n/**\n * Evaluation code from JSEP project, under MIT License.\n * Copyright (c) 2013 Stephen Oney, http://jsep.from.so/\n */\n\nconst binops = {\n  '||':  function (a, b) { return a || b; },\n  '&&':  function (a, b) { return a && b; },\n  '|':   function (a, b) { return a | b; },\n  '^':   function (a, b) { return a ^ b; },\n  '&':   function (a, b) { return a & b; },\n  '==':  function (a, b) { return a == b; }, // jshint ignore:line\n  '!=':  function (a, b) { return a != b; }, // jshint ignore:line\n  '===': function (a, b) { return a === b; },\n  '!==': function (a, b) { return a !== b; },\n  '<':   function (a, b) { return a < b; },\n  '>':   function (a, b) { return a > b; },\n  '<=':  function (a, b) { return a <= b; },\n  '>=':  function (a, b) { return a >= b; },\n  '<<':  function (a, b) { return a << b; },\n  '>>':  function (a, b) { return a >> b; },\n  '>>>': function (a, b) { return a >>> b; },\n  '+':   function (a, b) { return a + b; },\n  '-':   function (a, b) { return a - b; },\n  '*':   function (a, b) { return a * b; },\n  '/':   function (a, b) { return a / b; },\n  '%':   function (a, b) { return a % b; }\n};\n\nconst unops = {\n  '-' :  function (a) { return -a; },\n  '+' :  function (a) { return a; },\n  '~' :  function (a) { return ~a; },\n  '!' :  function (a) { return !a; },\n};\n\nfunction evaluateArray ( list, context ) {\n  return list.map(function (v) { return evaluate(v, context); });\n}\n\nasync function evaluateArrayAsync( list, context ) {\n  const res = await Promise.all(list.map((v) => evaluateAsync(v, context)));\n  return res;\n}\n\nfunction evaluateMember ( node, context ) {\n  const object = evaluate(node.object, context);\n  if ( node.computed ) {\n    return [object, object[evaluate(node.property, context)]];\n  } else {\n    return [object, object[node.property.name]];\n  }\n}\n\nasync function evaluateMemberAsync( node, context ) {\n  const object = await evaluateAsync(node.object, context);\n  if (  node.computed) {\n    return [object, object[await evaluateAsync(node.property, context)]];\n  } else {\n    return [object, object[node.property.name]];\n  }\n}\n\nfunction evaluate ( node, context ) {\n\n  switch ( node.type ) {\n\n    case 'ArrayExpression':\n      return evaluateArray( node.elements, context );\n\n    case 'BinaryExpression':\n      return binops[ node.operator ]( evaluate( node.left, context ), evaluate( node.right, context ) );\n\n    case 'CallExpression':\n      let caller, fn, assign;\n      if (node.callee.type === 'MemberExpression') {\n        assign = evaluateMember( node.callee, context );\n        caller = assign[0];\n        fn = assign[1];\n      } else {\n        fn = evaluate( node.callee, context );\n      }\n      if (typeof fn  !== 'function') { return undefined; }\n      return fn.apply( caller, evaluateArray( node.arguments, context ) );\n\n    case 'ConditionalExpression':\n      return evaluate( node.test, context )\n        ? evaluate( node.consequent, context )\n        : evaluate( node.alternate, context );\n\n    case 'Identifier':\n      return context[node.name];\n\n    case 'Literal':\n      return node.value;\n\n    case 'LogicalExpression':\n      if (node.operator === '||') {\n        return evaluate( node.left, context ) || evaluate( node.right, context );\n      } else if (node.operator === '&&') {\n        return evaluate( node.left, context ) && evaluate( node.right, context );\n      }\n      return binops[ node.operator ]( evaluate( node.left, context ), evaluate( node.right, context ) );\n\n    case 'MemberExpression':\n      return evaluateMember(node, context)[1];\n\n    case 'ThisExpression':\n      return context;\n\n    case 'UnaryExpression':\n      return unops[ node.operator ]( evaluate( node.argument, context ) );\n\n    default:\n      return undefined;\n  }\n\n}\n\nasync function evaluateAsync( node, context ) {\n\n  switch ( node.type ) {\n\n    case 'ArrayExpression':\n      return await evaluateArrayAsync( node.elements, context );\n\n    case 'BinaryExpression': {\n      const [left, right] = await Promise.all([\n        evaluateAsync( node.left, context ),\n        evaluateAsync( node.right, context )\n      ]);\n      return binops[ node.operator ]( left, right );\n    }\n\n    case 'CallExpression':\n      let caller, fn, assign;\n      if (node.callee.type === 'MemberExpression') {\n        assign = await evaluateMemberAsync( node.callee, context );\n        caller = assign[0];\n        fn = assign[1];\n      } else {\n        fn = await evaluateAsync( node.callee, context );\n      }\n      if (typeof fn !== 'function') {\n        return undefined;\n      }\n      return await fn.apply(\n        caller,\n        await evaluateArrayAsync( node.arguments, context ),\n      );\n\n    case 'ConditionalExpression':\n      return (await evaluateAsync( node.test, context ))\n        ? await evaluateAsync( node.consequent, context )\n        : await evaluateAsync( node.alternate, context );\n\n    case 'Identifier':\n      return context[node.name];\n\n    case 'Literal':\n      return node.value;\n\n    case 'LogicalExpression': {\n      if (node.operator === '||') {\n        return (\n          (await evaluateAsync( node.left, context )) ||\n          (await evaluateAsync( node.right, context ))\n        );\n      } else if (node.operator === '&&') {\n        return (\n          (await evaluateAsync( node.left, context )) &&\n          (await evaluateAsync( node.right, context ))\n        );\n      }\n\n      const [left, right] = await Promise.all([\n        evaluateAsync( node.left, context ),\n        evaluateAsync( node.right, context )\n      ]);\n\n      return binops[ node.operator ]( left, right );\n    }\n\n    case 'MemberExpression':\n      return (await evaluateMemberAsync(node, context))[1];\n\n    case 'ThisExpression':\n      return context;\n\n    case 'UnaryExpression':\n      return unops[ node.operator ](await evaluateAsync( node.argument, context ));\n\n    default:\n      return undefined;\n  }\n}\n\nfunction compile (expression) {\n  return evaluate.bind(null, jsep(expression));\n}\n\nfunction compileAsync(expression) {\n  return evaluateAsync.bind(null, jsep(expression));\n}\n\nmodule.exports = {\n  parse: jsep,\n  eval: evaluate,\n  evalAsync: evaluateAsync,\n  compile: compile,\n  compileAsync: compileAsync\n};\n","import * as expr from 'expression-eval';\n\nconsole.log(expr.eval(expr.parse('sqrt(3)')));\n","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else {\n        window.location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel]  Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel]   ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\"></span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}